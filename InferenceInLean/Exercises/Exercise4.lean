import InferenceInLean.Basic
import Mathlib.Data.Finset.Defs

set_option autoImplicit false

open Syntax
open Semantics
open Models
open Unification
open Inferences

variable {sig : Signature} {X : Variables} {univ : Universes}

/- ## Exercise 4 -/

namespace Exercise4

/- ### Exercise 4-1 -/

namespace Task1

inductive fs where | b | c | d | f deriving BEq
inductive ps where | P
def F : Formula ⟨fs, ps⟩ String := .and (.and (.and (.atom (.pred .P [.func .b []]))
  (.atom (.pred .P [.func .c []])))
  (.neg (.atom (.pred .P [.func .d []]))))
  (.neg (.ex "x" (.atom (.pred .P [.func .f [.func .f [.var "x"]]]))))

theorem ex_4_1 : ∃ I : Interpretation ⟨fs, ps⟩ (Fin 2), ∃ β : Assignment String (Fin 2),
    Formula.eval I β F := by
  let I : Interpretation ⟨fs, ps⟩ (Fin 2) := ⟨
    fun g a => if g == .f || g == .d then 1 else 0,
    fun _ u => if u[0]! == 0 then True else False⟩
  use I
  use (fun _ => 0)
  simp [I, F]
  have : fs.f == fs.f := rfl
  aesop

end Task1


/- ### Exercise 4-2 -/

namespace Task2

/- ! Rather large chunks of this namespace were generated by Claude 3.7 Sonnet (free version) !
  This worked somewhat well, the largest parts of the actual proofs were wrong though. -/

inductive funs where | plus | succ | zero deriving BEq

inductive preds where | eq deriving BEq

@[simp]
def sig42 : Signature := ⟨funs, preds⟩

@[simp]
def term_plus (t₁ t₂ : Term sig42 String) : Term sig42 String :=
  Term.func funs.plus [t₁, t₂]

@[simp]
def term_succ (t : Term sig42 String) : Term sig42 String :=
  Term.func funs.succ [t]

@[simp]
def term_zero : Term sig42 String :=
  Term.func funs.zero []

@[simp]
def atom_eq (t₁ t₂ : Term sig42 String) : Atom sig42 String :=
  Atom.pred preds.eq [t₁, t₂]

-- F₁ = ∀x (x + 0 ≈ x)
@[simp]
def F₁ : Formula sig42 String :=
  Formula.all "x" (
    Formula.atom (
      atom_eq
        (term_plus (Term.var "x") term_zero)
        (Term.var "x")))

-- F₂ = ∀x∀y (x + s(y) ≈ s(x + y))
@[simp]
def F₂ : Formula sig42 String :=
  Formula.all "x" (
    Formula.all "y" (
      Formula.atom (
        atom_eq
          (term_plus (Term.var "x") (term_succ (Term.var "y")))
          (term_succ (term_plus (Term.var "x") (Term.var "y"))))))

-- F₃ = ∀x∀y (x + y ≈ y + x)
@[simp]
def F₃ : Formula sig42 String :=
  Formula.all "x" (
    Formula.all "y" (
      Formula.atom (
        atom_eq
          (term_plus (Term.var "x") (Term.var "y"))
          (term_plus (Term.var "y") (Term.var "x")))))

-- F₄ = ¬∀x∀y (x + y ≈ y + x)
@[simp]
def F₄ : Formula sig42 String :=
  Formula.neg F₃

/- Part (a): Model of F₁, F₂, F₃ -/
theorem ex_4_2a : ∃ I : Interpretation sig42 (Fin 2), ∃ β : Assignment String (Fin 2),
    Formula.eval I β (.and (.and F₁ F₂) F₃) := by
  let I : Interpretation sig42 (Fin 2) := ⟨
    fun f args => match f with
      | .plus => (args[0]! + args[1]!) % 2
      | .succ => (args[0]! + 1) % 2
      | .zero => 0,
    fun _ args => args[0]! = args[1]!⟩

  use I
  use (fun _ => 0)
  simp [I, F₁, F₂, F₃]

  -- Prove F₁: ∀x (x + 0 ≈ x)
  have h₁ : ∀ (x : Fin 2), (x + 0) % 2 = x := by aesop

  -- Prove F₂: ∀x∀y (x + s(y) ≈ s(x + y))
  have h₂ : ∀ (x y : Fin 2), (x + ((y + 1) % 2)) % 2 = ((x + y) % 2 + 1) % 2 := by
    aesop (add norm Fin.add_def)

  -- Prove F₃: ∀x∀y (x + y ≈ y + x)
  have h₃ : ∀ (x y : Fin 2), (x + y) % 2 = (y + x) % 2 := by
    intro x y
    simp_all only [Fin.isValue, Fin.add_zero, I, Fin.add_def]
    rw [Nat.add_comm]

  simp_all only [Fin.add_zero, I]
  simp_all only [Fin.isValue, Nat.add_mod_mod, implies_true, true_and, I]


/- Part (b): Model of F₁, F₂, F₄ -/
theorem ex_4_2b : ∃ I : Interpretation sig42 (Fin 2), ∃ β : Assignment String (Fin 2),
    Formula.eval I β (.and (.and F₁ F₂) F₄) := by
  -- Define non-commutative interpretation
  let I : Interpretation sig42 (Fin 2) := ⟨
    -- Function interpretations
    fun f args => match f with
      | .plus => match args[0]!, args[1]! with
        | 0, 0 => 0
        | 1, 0 => 1
        | 0, 1 => 0
        | 1, 1 => 0
      | .succ => args[0]!  -- Identity function for successor
      | .zero => 0,
    fun _ args => args[0]! = args[1]!⟩
  use I
  use (fun _ => 0)
  simp [I, F₁, F₂, F₄]

  apply And.intro
  · aesop
  · use 0
    use 1
    exact Fin.zero_ne_one

end Task2


/- ### Exercise 4.6
  Let Σ = (Ω, Π) be a signature. For every Σ-formula F without equality,
  let neg(F) be the formula that one obtains from F by replacing every atom P(t1,...,tn)
  in F by its negation ¬P(t1,...,tn) for every P/n ∈ Π.
  Prove: If F is valid, then neg(F) is valid. -/

namespace Task6

/- ! Rather large chunks of this namespace were generated by Claude 3.7 Sonnet (free version) !
  Let's see if I want to fix this... -/

-- Define the neg function that negates all atoms in a formula
@[simp]
def negFormula {sig : Signature} {X : Variables} : Formula sig X → Formula sig X
  | Formula.falsum => Formula.falsum
  | Formula.verum => Formula.verum
  | Formula.atom a => Formula.neg (Formula.atom a)  -- replace atom with its negation
  | Formula.neg (Formula.atom a) => Formula.atom a  -- special case: double negation of atom
  | Formula.neg f => Formula.neg (negFormula f)
  | Formula.and f g => Formula.and (negFormula f) (negFormula g)
  | Formula.or f g => Formula.or (negFormula f) (negFormula g)
  | Formula.imp f g => Formula.imp (negFormula f) (negFormula g)
  | Formula.iff f g => Formula.iff (negFormula f) (negFormula g)
  | Formula.all x f => Formula.all x (negFormula f)
  | Formula.ex x f => Formula.ex x (negFormula f)

-- Define a "dual" interpretation that flips the truth value of all predicates
@[simp]
def dualInterpretation {sig : Signature} {univ : Universes}
    (I : Interpretation sig univ) : Interpretation sig univ :=
  ⟨I.functions, fun p args => ¬(I.predicates p args)⟩

theorem dualInterpretation.funs_eq {sig : Signature} {X : Variables} {univ : Universes}
    [DecidableEq X] (I : Interpretation sig univ) :
    I.functions = (dualInterpretation I).functions := rfl

-- Lemma: For any term t, eval(t) in the original interpretation is the same as in the dual
@[simp]
theorem term_eval_invariant {sig : Signature} {X : Variables} {univ : Universes}
    [DecidableEq X] (I : Interpretation sig univ) (β : Assignment X univ) (t : Term sig X) :
    Term.eval I β t = Term.eval (dualInterpretation I) β t := by
  induction' t using Term.induction with x args ih f <;> aesop

-- Lemma: For any atom a, eval(¬a) in the original interpretation equals eval(a) in the dual
@[simp]
theorem atom_eval_dual {sig : Signature} {X : Variables} {univ : Universes}
    [DecidableEq X] (I : Interpretation sig univ) (β : Assignment X univ) (a : Atom sig X) :
    ¬(Atom.eval I β a) ↔ Atom.eval (dualInterpretation I) β a := by
  simp [term_eval_invariant]
  induction a.2 with
  | nil => simp
  | cons head tail ih =>
    induction' head using Term.induction with x args ih f
    sorry
    sorry

-- Main theorem: The key equivalence - F evaluates to true in I iff neg(F) evaluates to true in dual(I)
theorem negFormula_eval_iff {sig : Signature} {X : Variables} {univ : Universes}
    [DecidableEq X] (I : Interpretation sig univ) (β : Assignment X univ) (F : Formula sig X) :
    Formula.eval I β F ↔ Formula.eval (dualInterpretation I) β (negFormula F) := by
  sorry

 -- Final theorem: If F is valid, then neg(F) is valid
theorem valid_negFormula {sig : Signature} {X : Variables} {univ : Universes}
    [DecidableEq X] (F : Formula sig X) :
    @Valid sig X univ _ F → @Valid sig X univ _ (negFormula F) := by
  intro h_valid I β
  simp_all only [Valid]
  have := h_valid I β
  have := (negFormula_eval_iff I β F).mp this
  sorry

end Task6


/- ### Exercise 4.7 (*)
  Let Π be a set of propositional variables. Let N and N' be sets
  of clauses over Π. Let S be a set of literals that does not contain any complementary
  literals. Prove: If every clause in N contains at least one literal L with L ∈ S and if no
  clause in N' contains a literal L with L ∈ S, then N ∪ N' is satisfiable if and only if N'
  is satisfiable.  -/

namespace Task7

def Interpretation.add (I : Interpretation ⟨Empty, String⟩ String)
    (β : Assignment Empty String) (L : Literal ⟨Empty, String⟩ Empty) :
    Interpretation ⟨Empty, String⟩ String :=
  -- add something to I such that Formula.eval L is true
  Interpretation.mk I.functions (match L with
    | Literal.pos a => match a with
      | Atom.pred p args =>
        have argsinter := args.map (Term.eval I β)
        (fun p' args' => if p' == p && args' == argsinter
          then True
          else I.predicates p' args')
    | Literal.neg a => match a with
      | Atom.pred p args =>
        have argsinter := args.map (Term.eval I β)
        (fun p' args' => if p' == p && args' == argsinter
          then False
          else I.predicates p' args')
  )

lemma tmp (I : Interpretation ⟨Empty, String⟩ String) (β : Assignment Empty String)
    (C : Clause ⟨Empty, String⟩ Empty)
    (hCsat : EntailsInterpret I β C) (L : Literal ⟨Empty, String⟩ Empty) (h : L.comp ∉ C) :
    EntailsInterpret (Interpretation.add I β L) β C := by
  sorry

theorem ex_4_7
    (N N' : Set <| Clause ⟨Empty, String⟩ Empty) (S : Set <| Literal ⟨Empty, String⟩ Empty)
    (hSnoCompl : ∀ L ∈ S, L.comp ∉ S)
    (hNsatByS : ∀ C ∈ N, ∃ L ∈ C, L ∈ S) (hN'noComplS : ∀ C ∈ N', ¬∃ L ∈ C, L.comp ∈ S) :
    (@ClauseSetSatisfiable _ _ univ _ (N ∪ N') ↔ @ClauseSetSatisfiable _ _ univ _ N') := by
  simp only [not_exists, not_and] at hN'noComplS
  apply Iff.intro
  · simp [ClauseSetSatisfiable]
    intro I β h
    apply Exists.intro
    · apply Exists.intro
      · intro C a
        apply h
        simp_all only [or_true]
  · simp [ClauseSetSatisfiable]
    intro I_N' β_N' hN'sat
    use I_N'
    use β_N' -- delay instanciation of assignment
    intro C hC
    cases hC
    next hCinN =>
      /- This is the actual hard case of this exercise. On paper it might look like this:
          - Show that I_N' and β_N' do not contradict (SAT N) (this is due to hN'noComplS)
          - Expand β_N' by the assignments implied by S to β_N'andS
          - then β_N'andS satisfies N using hNsatByS
      -/
      obtain ⟨L, ⟨hLinC, hLinS⟩⟩ := hNsatByS C hCinN
      have hLcompninS : L.comp ∉ S := by exact hSnoCompl L hLinS
      --let ?β := β_N'
      --let β_N'andS := β.modify L
      sorry

    next hCinN' => exact hN'sat C hCinN'

end Task7


end Exercise4
